// Elliott 900 emulator for Raspberry Pi Pico - Andrew Herbert - 29/03/2021

// Emulator for Elliott 903 / 920B.
// Does not implement 'undefined' effects.
// Has simplified handling of priority levels and initial orders.

// catastrophic error.

// GPIO pins


/**********************************************************/
/*                     HEADER FILES                       */
/**********************************************************/


#include <stdio.h>


/**********************************************************/
/*                         DEFINES                        */
/**********************************************************/


// Booleans
#define TRUE  1
#define FALSE 0

/* Useful constants */
#define BIT_19       01000000
#define MASK_18       0777777
#define MASK_18L      0777777L
#define BIT_18       00400000
#define MASK_16      00177777
#define ADDR_MASK        8191
#define MOD_MASK     00160000
#define MOD_SHIFT          13
#define FN_MASK            15
#define FN_SHIFT           13

// Locations of B register and SCR for priority levels 1 and 4
#define SCR_LEVEL_1  0
#define SCR_LEVEL_4  6
#define B_REG_LEVEL_1 1
#define B_REG_LEVEL_4 7

#define STORE_SIZE 8192 // 8K

// Codes for emulation failures

#define EMULATION_SCR_FAIL 3
#define EMULATION_14_FAIL  4
#define EMULATION_15_FAIL  5


/**********************************************************/
/*                         GLOBALS                        */
/**********************************************************/


/* these next two declarations will blow up if int < 19 bits */
const int           bits_18 =      262144;  // modulus for 18 bit operations
const long long int bits_36 = 68719476736L; // modulus for 64 bit operations

int store [STORE_SIZE]; // main store

/* Machine state */
int a_reg  = 0, q_reg  = 0;
int b_reg  = B_REG_LEVEL_1, sc_reg = SCR_LEVEL_1; // address in store of B register and SCR
int level = 1; // priority level
int instruction, f, a, m;


/**********************************************************/
/*                         FUNCTIONS                      */
/**********************************************************/


void wait_for_power();    // Wait for NOPOWER = 0
void wait_for_no_power(); // WAit for NOPOWER = 1
void emulate();           // run emulation
void clear_store();       // clear main store
int  read_tape();         // read from paper tape
void punch_tape(int ch);  // punch to paper tape
int  read_tty();          // read from teletype
void write_tty(int ch);   // write to teletype
void load_initial_instructions(); // load initial orders
int  make_instruction(int m, int f, int a); // help for load_initial_instructions
void set_up_gpios();      // initial GPIO interface to outside world
void emulation_fail(int code); // e.g., illegal instruction encountered
void slow_blink();        // signal waiting for NOPOWER = 0
void steady_glow();       // signal running
int  no_power();          // test for NOPOWER


/**********************************************************/
/*                           MAIN                         */
/**********************************************************/


int main (int argc, const char **argv) {
  set_up_gpios(); // configure interface to outside world
  while (TRUE)
    {
      wait_for_power(); // wait for external world to reset us
      clear_store();
      load_initial_instructions(); // load initial instructions into store
      store[sc_reg] = 8181; // jump to initial instructions
      emulate();  // run emulation
    }
}


/**********************************************************/
/*                         EMULATION                      */
/**********************************************************/


void emulate () {
  int last_scr = -1; // scr of previous instruction
  int s; // current SCR value

  // set up machine ready to execute
  clear_store(); // start with a cleared store
  load_initial_instructions();// load initial orders
  store[sc_reg] = 8181; // execute initial orders

  // instruction fetch and decode loop
  while (TRUE )
    {
      if ( no_power() ) return;
      
      // increment SCR
      last_scr = store[sc_reg];         // remember SCR
      if   ( last_scr >= STORE_SIZE )
        {
	  printf("*** SCR has overflowed the store (SCR = %d)\n", last_scr);
          emulation_fail(EMULATION_SCR_FAIL);
 	  /* NOT REACHED */
        }
      s = ++store[sc_reg];                 // increment SCR

      // fetch and decode instruction;
      instruction = store[last_scr];
      f = (instruction >> FN_SHIFT) & FN_MASK;
      a = (instruction & ADDR_MASK) | (last_scr & MOD_MASK);

      // perform B modification if needed
      if ( instruction >= BIT_18 )
        {
  	  m = (a + store[b_reg]) & MASK_16;
	}
      else
	  m = a & MASK_16;

      // perform function determined by function code f
      switch ( f )
        {

        case 0: // Load B
	    q_reg = store[m]; store[b_reg] = q_reg;
	    break;

          case 1: // Add
       	    a_reg = (a_reg + store[m]) & MASK_18;
	    break;

          case 2: // Negate and add
	    a_reg = (store[m] - a_reg) & MASK_18;
	    break;

          case 3: // Store Q
	    store[m] = q_reg >> 1;
	    break;

          case 4: // Load A
	    a_reg = store[m];
	    break;

          case 5: // Store A
	    if   ( level == 1 && m >= 8180 && m <= 8191 )
	      {
		break; // ignore write to II at level 1
	      }
	    else
	      store[m] = a_reg; 
	    break;

          case 6: // Collate
	    a_reg &= store[m];
	    break;

          case 7: // Jump if zero
  	    if   ( a_reg == 0 ) store[sc_reg] = s = m;
	    break;

          case 8: // Jump unconditional
	    store[sc_reg] = s = m;
	    break;

          case 9: // Jump if negative
	    if   ( a_reg >= BIT_18 ) store[sc_reg] = s = m;
	    break;

          case 10: // increment in store
 	    store[m] = (store[m] + 1) & MASK_18;
	    break;

          case 11:  // Store S
	    {
              int s = store[sc_reg];
	      q_reg = s & MOD_MASK;
	      store[m] = s & ADDR_MASK;
	      break;
	    }

          case 12:  // Multiply
	    {
	      // extend sign bits for a and store[m]
	      long long al = (long long) ( ( a_reg >= BIT_18 ) ? a_reg - BIT_19 : a_reg );
	      long long sl = (long long) ( ( store[m] >= BIT_18 ) ? store[m] - BIT_19 : store[m] );
	      long long  prod = al * sl;
	      q_reg = (int) ((prod << 1) & MASK_18L );
	      if   ( al < 0 ) q_reg |= 1;
	      prod = prod >> 17; // arithmetic shift
 	      a_reg = (int) (prod & MASK_18L);
	      break;
	    }

          case 13:  // Divide
	    {
	      // extend sign bit for aq
	      long long al   = (long long) ( ( a_reg >= BIT_18 ) ? a_reg - BIT_19 : a_reg ); // sign extend
	      long long ql   = (long long) q_reg;
	      long long aql  = (al << 18) | ql;
	      long long ml   = (long long) ( ( store[m] >= BIT_18 ) ? store[m] - BIT_19 : store[m] );
              long long quot = (( aql / ml) >> 1) & MASK_18L;
	      int q     = (int) quot;
  	      a_reg = q | 1;
	      q_reg = q & 0777776;
	      break;
	    }

          case 14:  // Shift - assumes >> applied to a signed long or int is arithmetic
	    {
              int places = m & ADDR_MASK;
	      long long al  = (long long) ( ( a_reg >= BIT_18 ) ? a_reg - BIT_19 : a_reg ); // sign extend
	      long long ql  = q_reg;
	      long long aql = (al << 18) | ql;
	      
	      if   ( places <= 2047 )
	        {
	          if   ( places >= 36 ) places = 36;
	          aql <<= places;
	        }
	      else if ( places >= 6144 )
	        { // right shift is arithmetic
	          places = 8192 - places;
	          if ( places >= 36 ) places = 36;
		  aql >>= places;
	        }  
	      else
	        {
	          printf("*** Unsupported i/o 14 i/o instruction\n");
	          emulation_fail(EMULATION_14_FAIL);
	          /* NOT REACHED */
	        }

	      q_reg = (int) (aql & MASK_18L);
	      a_reg = (int) ((aql >> 18) & MASK_18L);
	      break;
	    }

            case 15:  // Input/output etc
	      {
                int z = m & ADDR_MASK;
	        switch   ( z )
	    	  {

		    case 2048: // read from tape reader
		      { 
	                int ch = read_tape(); 
	                a_reg = ((a_reg << 7) | ch) & MASK_18;
	                break;
	               }

	            case 2052: // read from teletype
		      {
	                int ch = read_tty();
	                a_reg = ((a_reg << 7) | ch) & MASK_18;
	                break;
	              }

	            case 6144: // write to paper tape punch 
	              punch_tape(a_reg & 255);
	              break;

	            case 6148: // write to teletype
	              write_tty(a_reg & 255);
	              break;	      
	  
	            case 7168:  // Level terminate
	              level = 4;
	              sc_reg = SCR_LEVEL_4;
		      b_reg  = B_REG_LEVEL_4;
	              break;

	            default:
	              printf("*** Unsupported 15 i/o instruction\n");
		      emulation_fail(EMULATION_15_FAIL);
	              /* NOT REACHED */
		  } // end 15 switch
	      } // end case 15
	} // end function switch
    } // end while fetching and decoding instructions
}

void clear_store() {
  int i;
  for ( i=0 ; i < STORE_SIZE ; ++i ) store[i] = 0;
}

/**********************************************************/
/*                    PAPER TAPE SYSTEM                   */
/**********************************************************/


/* Paper tape reader */
int read_tape() {
  puts("Read from paper tape\n");
  return 0;   // Too keep gcc happy
}

/* paper tape punch */
void punch_tape(int ch) {
  puts("Punch to paper tape\n");
  return;
}

/* Teletype */
int read_tty() {
    return 0;   // Too keep gcc happy
}

void write_tty(int ch) {
  puts("Type to teleprinter\n");
  return;
}


/**********************************************************/
/*               INITIAL INSTRUCTIONS                     */
/**********************************************************/


void load_initial_instructions() {
  store[8180] = (-3 & MASK_18);
  store[8181] = make_instruction(0,  0, 8180);
  store[8182] = make_instruction(0,  4, 8189);
  store[8183] = make_instruction(0, 15, 2048);
  store[8184] = make_instruction(0,  9, 8186);
  store[8185] = make_instruction(0,  8, 8183);
  store[8186] = make_instruction(0, 15, 2048);
  store[8187] = make_instruction(1,  5, 8180);
  store[8188] = make_instruction(0, 10,    1);
  store[8189] = make_instruction(0,  4,    1);
  store[8190] = make_instruction(0,  9, 8182);
  store[8191] = make_instruction(0,  8, 8177);
  printf("Initial orders loaded\n");
}

int make_instruction(int m, int f, int a) {
  return ((m << 17) | (f << 13) | a);
}

/**********************************************************/
/*                         PICO                           */
/**********************************************************/

void set_up_gpios() {
  return;
}

void emulation_fail(int code) {
  // flash code then pause
  while (TRUE) {
    printf("Emulation failed: %d\n", code);
  }
}

void slow_blink() {
  return;
}

void steady_glow() {
  return;
}

int no_power() {
  return FALSE;
}

void wait_for_power() {
  return;
}

void wait_for_no_power() {
  return;
}
